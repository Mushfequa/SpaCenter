/*
	Form related utilities module
*/
var _ = require('lodash'),

	/*
		A field object is this structure:

		{
			//	Any attributes, eg: id, etc. (optional)
			name: "",		// Name of the field (optional)
			options: [],		// Any options, for selectboxes, etc (optional)
			meta: {}			// Any other attributes, eg: label, placeholder, etc.
		}

		These will be used in the construction in the template.
		Any other attributes can be passed through, and used for
		other things, eg: validation, etc, and won't be rendered 
		as an attribute ...

	*/

	applyField = function(field, name, translateFunc) {
		field.meta = field.meta || {};
		field.name = name;

		//	Grab any attributes that are assigned directly on the field object
		_.forOwn(field, function(value, key) {
			if(key !== "meta" && key !== "options") {
				field[key] = value;
			}
		});

		//	Merge fields with their translations
		tmp = translateFunc(name + 'Field');
		if(typeof tmp == "object") {
			field.meta = _.merge(field.meta || {}, tmp);
		}

		//	Merge ID based translations
		tmp = translateFunc(name + 'Field_' + field.id);
		if(typeof tmp == "object") {
			field.meta = _.merge(field.meta, tmp);
		}

		//	Merge options with translations
		if(field.options) {
			field.options = field.options;
			_.forOwn(field.options, function(optValue, optIndex){
				//	Merge options with their translations
				tmp = translateFunc(name + 'Field_' + optValue.id);

				if(typeof tmp == "object") {
					field.options[optIndex].meta = field.options[optIndex].meta || {};
					field.options[optIndex].meta = _.merge(field.options[optIndex].meta, tmp);
				}

			});
		}

		return field;
	};



module.exports = {

	//	TODO: Finish creating form mappings translation for sequelizejs 
	//	model - need to test with more elaborate models.
	//	Note: we do this so we are loosely coupled to sequelize
	//	optional: formName, in case we want to prefix field names
	//	where there might be more than one form on the page
	sequelizeModelToForm: function(model, formName) {
		var o = {}, tmp, validators;

		_.forOwn(model.rawAttributes, function(value, key){
			validators = (value.validate)? value.validate: null;

			tmp = {
				//	Set the name, optionally prefixing
				name: (formName)? formName + "_" + key: key,
				//	Set the value
				value: model.dataValues? model.dataValues[key]: undefined,
				//	Any meta data
				meta: {
					required: (value.allowNull == false),
					validate: validators
				}
			};

			//	Set the data-validate attribute
			if(validators) {
				tmp['data-validate'] = JSON.stringify(validators).split('"').join('&quot;');
			}

			o[key] = tmp;
		});

		return o;
	},


	//	Populate a sequelize model from a form
	//	TODO: We need this when a formName is specified
	formToSequelizeModel: function(model, data, formName) {
		//	TODO: use form name to gather the data
		return model.build(data);
	},



	//	Creates a form object, resolving 
	//	translated field labels, hints, etc, via 
	//	the passed in translation function
	//	
	//	TODO: For production - Caching - should be able to load the form
	//		from cache based on language, and just update the values.
	form: function(fields, translateFunc){

		//	Set names and translated items
		_.forOwn(fields, function(value, name){
			var tmp, isArr;

			//	Allow a list of fields to be passed through
			if(_.isArray(value)) {
				//	Process the fields
				fields[name] = [];
				_.forOwn(value, function(field) {
					fields[name].push(applyField(field, name, translateFunc));
				})
			} else {
				fields[name] = applyField(value, name, translateFunc);
			}
		});

		return fields;
	}
};